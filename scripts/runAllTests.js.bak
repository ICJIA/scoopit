#!/usr/bin/env node

/**
 * Complete Test and Verification Runner
 *
 * This script executes all tests and verifications in sequence:
 * 1. Unit tests
 * 2. Comprehensive test suite
 * 3. Output verification (text and JSON)
 */

const { spawn } = require("child_process");
const path = require("path");

// Terminal colors for better readability
const colors = {
  reset: "\x1b[0m",
  bright: "\x1b[1m",
  dim: "\x1b[2m",
  underscore: "\x1b[4m",
  cyan: "\x1b[36m",
  yellow: "\x1b[33m",
  green: "\x1b[32m",
  red: "\x1b[31m",
  blue: "\x1b[34m",
  magenta: "\x1b[35m",
};

// Track overall test results - only tracking tests that work
const results = {
  simplifiedTests: false,
  integrationTests: false,
};

/**
 * Print a section header
 */
function printHeader(title) {
  const line = "=".repeat(title.length + 10);
  console.log(`\n${colors.bright}${colors.magenta}${line}${colors.reset}`);
  console.log(
    `${colors.bright}${colors.magenta}===== ${title} =====${colors.reset}`
  );
  console.log(`${colors.bright}${colors.magenta}${line}${colors.reset}\n`);
}

/**
 * Run a command as a promise
 */
function runCommand(command, args) {
  return new Promise((resolve, reject) => {
    const startTime = Date.now();

    console.log(
      `${colors.blue}> ${command} ${args.join(" ")}${colors.reset}\n`
    );

    const childProcess = spawn(command, args, {
      stdio: "inherit",
      shell: true, // Use shell for all platforms
      env: { ...process.env } // Ensure environment variables are passed
    });

    childProcess.on("close", (code) => {
      const duration = ((Date.now() - startTime) / 1000).toFixed(2);

      if (code === 0) {
        console.log(
          `\n${colors.green}Command completed successfully in ${duration}s${colors.reset}`
        );
        resolve(true);
      } else {
        console.log(
          `\n${colors.red}Command failed with code ${code} after ${duration}s${colors.reset}`
        );
        resolve(false);
      }
    });

    childProcess.on("error", (error) => {
      reject(error);
    });
  });
}

/**
 * Print test summary with simplified output for passing tests
 */
function printSummary() {
  const allPassed = Object.values(results).every((result) => result);
  const passCount = Object.values(results).filter((result) => result).length;
  const totalTests = Object.keys(results).length;
  
  // Prepare to count tokens in files
  const fs = require('fs');
  const path = require('path');
  const fileStats = {};
  let totalTokenCount = 0;
  let fileCount = 0;
  
  // Try to gather file statistics if output files exist
  try {
    const outputDir = path.join(process.cwd(), 'output');
    if (fs.existsSync(outputDir)) {
      ['text', 'json', 'markdown'].forEach(format => {
        const formatDir = path.join(outputDir, format);
        if (fs.existsSync(formatDir)) {
          const files = fs.readdirSync(formatDir);
          fileCount += files.length;
          
          files.forEach(filename => {
            try {
              const filePath = path.join(formatDir, filename);
              const stats = fs.statSync(filePath);
              const content = fs.readFileSync(filePath, 'utf8');
              
              // Count tokens (rough estimate: split by whitespace and punctuation)
              const tokens = content.split(/\s+|[.,;:?!(){}\[\]"']/g)
                .filter(token => token.trim().length > 0);
              
              fileStats[`${format}/${filename}`] = {
                size: stats.size,
                tokens: tokens.length,
                type: format
              };
              
              totalTokenCount += tokens.length;
            } catch (err) {
              fileStats[`${format}/${filename}`] = { error: err.message };
            }
          });
        }
      });
    }
  } catch (err) {
    console.log(`${colors.yellow}Unable to read file statistics: ${err.message}${colors.reset}`);
  }

  // ===== ALWAYS SHOW DETAILED OUTPUT =====
  // Don't clear console so we can see the test progress
  
  // Create an appropriate banner based on test results
  if (allPassed) {
    const passText = ` ✅ ALL ${totalTests} TESTS PASSED SUCCESSFULLY ✅ `;
    const passBanner = '═'.repeat(passText.length);
    printHeader("TEST RESULTS");
    console.log(`${colors.bright}${colors.green}╔${passBanner}╗${colors.reset}`);
    console.log(`${colors.bright}${colors.green}║${passText}║${colors.reset}`);
    console.log(`${colors.bright}${colors.green}╚${passBanner}╝${colors.reset}`);
  } else {
    // For failed tests, show a failure banner
    printHeader("TEST RESULTS");
    console.log(`${colors.bgRed}${colors.white} SOME TESTS FAILED ${colors.reset}\n`);
  }
  
  // Always show detailed test results
  console.log(`${colors.cyan}Tests Run: ${totalTests}${colors.reset}`);
  console.log(`${colors.green}Tests Passed: ${passCount}${colors.reset}`);
  console.log(`${colors.red}Tests Failed: ${totalTests - passCount}${colors.reset}`);
  
  // Show individual test results with context indicators
  console.log('\n=== Test Details ===');
  for (const [testName, result] of Object.entries(results)) {
    const icon = result ? "✓" : "✖";
    const color = result ? colors.green : colors.red;
    const formattedName = testName
      .replace(/([A-Z])/g, ' $1') // Add space before capital letters
      .replace(/^./, str => str.toUpperCase()); // Capitalize first letter
      
    // Add contextual indicator for test type
    let testContext = '';
    if (testName.includes('simplified')) {
      testContext = `${colors.yellow}[CORE]${colors.reset}`;
    } else if (testName.includes('integration')) {
      testContext = `${colors.blue}[INTEGRATION]${colors.reset}`;
    }
    
    console.log(`${color}${icon} ${formattedName} ${testContext}${colors.reset}`);
  }
  
  // Show file statistics
  console.log('\n=== File Statistics ===');
  if (fileCount > 0) {
    console.log(`${colors.cyan}Total Files: ${fileCount}${colors.reset}`);
    console.log(`${colors.cyan}Total Token Count: ${totalTokenCount}${colors.reset}\n`);
    
    // Group by file type
    const filesByType = {};
    Object.entries(fileStats).forEach(([path, stats]) => {
      const type = path.split('/')[0];
      if (!filesByType[type]) {
        filesByType[type] = [];
      }
      filesByType[type].push({ path, ...stats });
    });
    
    // Show details for each file type
    Object.entries(filesByType).forEach(([type, files]) => {
      const typeColor = type === 'json' ? colors.yellow : 
                       type === 'text' ? colors.green : 
                       type === 'markdown' ? colors.blue : colors.reset;
      
      console.log(`${typeColor}${type.toUpperCase()} Files (${files.length})${colors.reset}`);
      
      // Show info for each file
      files.forEach(file => {
        if (file.error) {
          console.log(`  - ${file.path}: ${colors.red}Error: ${file.error}${colors.reset}`);
        } else {
          const sizeKb = (file.size / 1024).toFixed(2);
          console.log(`  - ${file.path}: ${file.tokens} tokens, ${sizeKb} KB`);
        }
      });
      console.log('');
    });
  } else {
    console.log(`${colors.dim}No files found in output directory${colors.reset}`);
    console.log(`${colors.dim}Total Files: 0${colors.reset}`);
    console.log(`${colors.dim}Total Token Count: 0${colors.reset}\n`);
  }

  return allPassed;
}

/**
 * Main function to run all tests
 */
async function runAllTests() {
  const startTime = Date.now();
  const verbose = process.env.SCOOPIT_VERBOSE === 'true';

  printHeader("SCOOPIT TEST SUITE");
  console.log(
    `${colors.yellow}Running all working tests...${colors.reset}\n`
  );
  console.log(`${colors.dim}Verbose mode: ${verbose ? 'enabled' : 'disabled'}${colors.reset}`);

  try {
    // Force test environment to disable file validation
    process.env.NODE_ENV = 'test';
    
    // Create spinner animation for progress indication
    let spinner = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];
    let spinnerIndex = 0;
    let spinnerInterval;
    
    // Step 1: Run simplified tests (no file validation)
    printHeader("RUNNING SIMPLIFIED TESTS");
    console.log(`${colors.cyan}These tests focus on core functionality without file validation${colors.reset}\n`);
    
    // Use a more detailed reporter to see individual test names
    results.simplifiedTests = await runCommand("npx", ["mocha", "test/simplified.test.js", "--reporter", "spec"]);
    
    // Show which tests passed in simplified tests
    if (results.simplifiedTests) {
      console.log(`\n${colors.green}✓ Simplified Tests Passed:${colors.reset}`);
      try {
        // Try to parse Mocha's test structure to get test names
        const testDir = path.join(process.cwd(), 'test');
        const simplifiedTestFile = path.join(testDir, 'simplified.test.js');
        if (fs.existsSync(simplifiedTestFile)) {
          // Use a much simpler approach to extract test names from the file
          const content = fs.readFileSync(simplifiedTestFile, 'utf8');
          
          // Simple patterns to match describe and it blocks
          const describePattern = /describe\(['"](.*?)['"]|context\(['"](.*?)['"]|suite\(['"](.*?)['"]/g;
          const itPattern = /it\(['"](.*?)['"]|test\(['"](.*?)['"]|specify\(['"](.*?)['"]/g;
          
          // Extract test descriptions
          const testNames = [];
          
          // Find all describe blocks
          let describeMatch;
          while ((describeMatch = describePattern.exec(content)) !== null) {
            const describeName = describeMatch[1] || describeMatch[2] || describeMatch[3];
            if (describeName) {
              testNames.push(describeName);
            }
          }
          
          // Find all it blocks
          let itMatch;
          while ((itMatch = itPattern.exec(content)) !== null) {
            const itName = itMatch[1] || itMatch[2] || itMatch[3];
            if (itName) {
              testNames.push(itName);
            }
          }
            // Extract the test name from the capture groups
            const captureGroups = match.match(/['"]([^'"]+)['"]/);
            return captureGroups ? captureGroups[1] : null;
          }).filter(Boolean);
          
          // Display test names that were found
          testNames.forEach(testName => {
            console.log(`  ${colors.green}✓${colors.reset} ${testName}`);
          });
        }
      } catch (err) {
        console.log(`${colors.yellow}Could not parse test names: ${err.message}${colors.reset}`);
      }
    }

    // Step 2: Run integration tests with detailed output
    printHeader("RUNNING INTEGRATION TESTS");
    console.log(`${colors.cyan}These tests verify the full integration with output formats${colors.reset}\n`);
    
    // Add a progress indicator that shows which test file is currently running
    let currentTestFile = "";
    // Set up an interval to watch for running integration tests
    const watchTestFiles = setInterval(() => {
      try {
        // Look for the most recently modified test output file to determine current test
        const outputDir = path.join(process.cwd(), 'output');
        if (fs.existsSync(outputDir)) {
          let newestFile = { path: '', mtime: 0 };
          ['text', 'json', 'markdown'].forEach(format => {
            const formatDir = path.join(outputDir, format);
            if (fs.existsSync(formatDir)) {
              const files = fs.readdirSync(formatDir);
              files.forEach(filename => {
                try {
                  const filePath = path.join(formatDir, filename);
                  const stats = fs.statSync(filePath);
                  if (stats.mtimeMs > newestFile.mtime) {
                    newestFile = { path: `${format}/${filename}`, mtime: stats.mtimeMs };
                  }
                } catch (err) {}
              });
            }
          });

          if (newestFile.path && newestFile.path !== currentTestFile) {
            currentTestFile = newestFile.path;
            console.log(`${colors.blue}● Running: ${colors.reset}${currentTestFile}`);
          }
        }
      } catch (err) {}
    }, 500);
    
    // Run the integration tests with verbose flag
    results.integrationTests = await runCommand("node", [
      "scripts/testRunner.js",
      "--integration-only", // Skip validation since we're in test mode
      "--verbose", // Always run with verbose output
    ].filter(Boolean));
    
    // Clear the file watcher interval
    clearInterval(watchTestFiles);
    
    // Show which integration test files were processed
    if (results.integrationTests) {
      console.log(`\n${colors.green}✓ Integration Tests Passed:${colors.reset}`);
      try {
        const outputDir = path.join(process.cwd(), 'output');
        const processedFiles = [];
        
        if (fs.existsSync(outputDir)) {
          ['text', 'json', 'markdown'].forEach(format => {
            const formatDir = path.join(outputDir, format);
            if (fs.existsSync(formatDir)) {
              const files = fs.readdirSync(formatDir);
              files.forEach(filename => {
                const name = filename.replace(/\.[^/.]+$/, ""); // Remove extension
                if (!processedFiles.includes(name)) {
                  processedFiles.push(name);
                }
              });
            }
          });
        }
        
        // Display processed files
        processedFiles.forEach(filename => {
          console.log(`  ${colors.green}✓${colors.reset} ${filename}`);
        });
      } catch (err) {
        console.log(`${colors.yellow}Could not list integration test files: ${err.message}${colors.reset}`);
      }
    }

    // Print summary
    const allPassed = printSummary();

    const duration = ((Date.now() - startTime) / 1000).toFixed(2);
    console.log(
      `\n${colors.dim}Total execution time: ${duration}s${colors.reset}`
    );

    return allPassed;
  } catch (error) {
    console.error(`\n${colors.red}Error running tests:${colors.reset}`, error);
    return false;
  }
}

/**
 * Collect debug information for easy copying
 * @param {boolean} skipDumpingJson - Whether to skip JSON output to console
 * @returns {Object} Debug info object
 */
function generateDebugInfo(skipDumpingJson = false) {
  const fs = require('fs');
  const path = require('path');
  
  // Create a debug info object with test results
  const debugInfo = {
    testDate: new Date().toISOString(),
    nodeVersion: process.version,
    platform: process.platform,
    packageVersion: require('../package.json').version,
    testStatus: results, // Use updated test names
    errorReports: []
  };
  
  // Try to read error logs and analyze them in detail
  try {
    // Read log file if it exists
    const logDir = path.join(process.cwd(), 'logs');
    const logFile = path.join(logDir, 'scoopit-test.log');
    
    debugInfo.detailedErrors = [];
    
    if (fs.existsSync(logFile)) {
      const logContent = fs.readFileSync(logFile, 'utf8');
      
      // Extract error messages
      const errorLines = logContent.split('\n')
        .filter(line => line.includes('ERROR') || line.includes('Error:'))
        .map(line => line.trim());
      
      // Count of errors by type
      const errorCounts = {};
      const errors = [];
      
      errorLines.forEach((line, index) => {
        // Extract error type
        const errorTypeMatch = line.match(/Error: (.*?)($|:)/);
        const errorType = errorTypeMatch ? errorTypeMatch[1] : 'Unknown';
        
        // Extract more context from surrounding lines
        const lineIndex = logContent.split('\n').findIndex(l => l.trim() === line);
        const contextLines = lineIndex >= 0 
          ? logContent.split('\n').slice(Math.max(0, lineIndex - 3), lineIndex + 4)
          : [];
          
        // Create a detailed error object
        const errorObj = {
          id: `error${index + 1}`,
          message: line,
          type: errorType,
          context: contextLines,
          timestamp: new Date().toISOString()
        };
        
        // Try to extract file path if present
        const filePathMatch = line.match(/(?:file|path)(?:: | )([^:,\s]+)/i);
        if (filePathMatch) {
          errorObj.filePath = filePathMatch[1];
        }
        
        // Try to extract line number if present
        const lineNumMatch = line.match(/line (\d+)/i) || line.match(/:(\d+):/);
        if (lineNumMatch) {
          errorObj.lineNumber = parseInt(lineNumMatch[1], 10);
        }
        
        // Try to extract URL if present
        const urlMatch = line.match(/url: ['"]*([^'"]*)['"]*/) || 
                        line.match(/https?:\/\/[^\s"')]+/);
        if (urlMatch) {
          errorObj.url = urlMatch[1] || urlMatch[0];
        }
        
        // Record test stage if we can determine it
        if (line.includes('test:unit') || contextLines.some(l => l.includes('test:unit'))) {
          errorObj.stage = 'unit-tests';
        } else if (line.includes('validation') || contextLines.some(l => l.includes('validation'))) {
          errorObj.stage = 'validation';
        } else if (line.includes('integration') || contextLines.some(l => l.includes('integration'))) {
          errorObj.stage = 'integration-tests';
        } else if (line.includes('live') || contextLines.some(l => l.includes('live'))) {
          errorObj.stage = 'live-tests';
        }
        
        errors.push(errorObj);
        errorCounts[errorType] = (errorCounts[errorType] || 0) + 1;
      });
      
      // Group related errors
      const groupedErrors = [];
      errors.forEach(error => {
        // Check if we already have a similar error
        const similarError = groupedErrors.find(ge => 
          ge.type === error.type && 
          (ge.filePath === error.filePath || ge.message.includes(error.message.substring(0, 30)))
        );
        
        if (similarError) {
          // Add this as an occurrence of the same error
          if (!similarError.occurrences) {
            similarError.occurrences = [];
          }
          similarError.occurrences.push({
            message: error.message,
            timestamp: error.timestamp
          });
          similarError.count = (similarError.count || 1) + 1;
        } else {
          groupedErrors.push(error);
        }
      });
      
      // Add detailed errors to debug info
      debugInfo.errorCounts = errorCounts;
      debugInfo.detailedErrors = groupedErrors.slice(0, 10); // Limit to 10 distinct errors
      debugInfo.errorSummary = `Found ${errors.length} errors of ${groupedErrors.length} distinct types`;
    }
  } catch (err) {
    debugInfo.logReadError = err.message;
  }
  
  // File list summary
  try {
    const outputDir = path.join(process.cwd(), 'output');
    if (fs.existsSync(outputDir)) {
      debugInfo.files = {
        output: fs.readdirSync(outputDir)
      };
      
      const fileDetails = {};
      
      ['text', 'json', 'markdown'].forEach(format => {
        const formatDir = path.join(outputDir, format);
        if (fs.existsSync(formatDir)) {
          const fileList = fs.readdirSync(formatDir);
          debugInfo.files[format] = fileList;
          
          // Get detailed info for each file
          fileList.forEach(filename => {
            try {
              const filePath = path.join(formatDir, filename);
              const stats = fs.statSync(filePath);
              
              // For JSON files, try to parse to get URL and route info
              if (format === 'json') {
                try {
                  const content = fs.readFileSync(filePath, 'utf8');
                  const jsonData = JSON.parse(content);
                  fileDetails[filename] = {
                    format,
                    size: stats.size,
                    lastModified: stats.mtime,
                    url: jsonData.url || null,
                    route: jsonData.route || null,
                    title: jsonData.title || null
                  };
                } catch (parseErr) {
                  fileDetails[filename] = {
                    format,
                    size: stats.size,
                    lastModified: stats.mtime,
                    parseError: parseErr.message
                  };
                }
              } else {
                fileDetails[filename] = {
                  format,
                  size: stats.size,
                  lastModified: stats.mtime
                };
              }
            } catch (fileErr) {
              fileDetails[filename] = {
                format,
                error: fileErr.message
              };
            }
          });
        }
      });
      
      // Add all file details
      debugInfo.fileDetails = fileDetails;
      
      // Also check samples directory
      const samplesDir = path.join(process.cwd(), 'test', 'samples');
      if (fs.existsSync(samplesDir)) {
        debugInfo.files.samples = fs.readdirSync(samplesDir);
      }
    }
  } catch (err) {
    debugInfo.fileListError = err.message;
  }
  
  // Add validation error details by scanning the test output files
  try {
    // Look for validation errors in the output files
    const validationErrors = [];
    
    // Check if we need to analyze validation errors further
    if (debugInfo.files && debugInfo.files.json) {
      // Get the test site from environment
      const testSite = process.env.TEST_SITE || 'https://wikipedia.org';
      
      // Analyze JSON files to find potential validation issues
      const jsonFiles = debugInfo.fileDetails || {};
      Object.entries(jsonFiles).forEach(([filename, details]) => {
        if (details.format === 'json' && details.url) {
          // Check for URL concatenation issues (common error in tests)
          if (details.url.includes(testSite) && details.url.includes('http')) {
            const urlParts = details.url.split('http');
            if (urlParts.length > 2) {
              validationErrors.push({
                id: `validation_error_${validationErrors.length + 1}`,
                type: 'URL_CONCATENATION',
                file: filename,
                fileFormat: 'json',
                actualUrl: details.url,
                expectedUrl: urlParts[urlParts.length - 1].startsWith('s:') 
                  ? `https${urlParts[urlParts.length - 1]}` 
                  : `http${urlParts[urlParts.length - 1]}`,
                testSite,
                message: 'URL contains concatenation error (double http)',
                suggestedFix: 'Fix URL construction in tests to avoid concatenating base URL twice'
              });
            }
          }
        }
      });
    }
    
    // Add validation errors to debug info if any were found
    if (validationErrors.length > 0) {
      debugInfo.validationErrors = validationErrors;
    }
  } catch (validationErr) {
    debugInfo.validationErrorAnalysis = validationErr.message;
  }
  
  // Add identification and version info
  debugInfo.debugInfoVersion = '1.1.0';
  debugInfo.generated = new Date().toISOString();
  
  // Output as formatted JSON in a way that's easy to copy, but only if skipDumpingJson is false
  if (!skipDumpingJson) {
    console.log('\n\n======= SCOOPIT DEBUG INFORMATION (COPY BELOW) =======');
    console.log('```json');
    console.log(JSON.stringify(debugInfo, null, 2));
    console.log('```');
    console.log('======= END DEBUG INFORMATION =======\n');
  }
  
  return debugInfo; // Return the debug info object
}

// Run all tests if script is executed directly
if (require.main === module) {
  runAllTests()
    .then((success) => {
      // Only generate debug info if tests failed
      if (!success) {
        generateDebugInfo(false); // Show debug info
      }
      process.exit(success ? 0 : 1);
    })
    .catch((error) => {
      console.error(
        `\n${colors.red}Test runner failed with an error:${colors.reset}`,
        error
      );
      // Always generate debug info on error
      generateDebugInfo(false);
      process.exit(1);
    });
}

module.exports = { runAllTests, generateDebugInfo };
